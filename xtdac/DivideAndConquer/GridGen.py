# Author: Giacomo Vianello (giacomov@stanford.edu)

import numpy


class GridGen(object):
    '''
    Generate a grid in detector coordinates
    '''

    def __init__(self, hardwareUnit):
        # Store hardware unit
        self.hardwareUnit = hardwareUnit

    def makeGrid(self, approxSizeArcsec=80.35, unit='sky', multiplicity=2.0, get_psf_size=None):

        # Convert from arcsec to pixels units
        approxSize = approxSizeArcsec / self.hardwareUnit.getPixelScale()

        # Get maximum and minimum in the X and Y directions
        # from the hardware unit
        if (unit == 'physical'):

            (minx, maxx) = (self.hardwareUnit.getMinDETX(),
                            self.hardwareUnit.getMaxDETX())
            (miny, maxy) = (self.hardwareUnit.getMinDETY(),
                            self.hardwareUnit.getMaxDETY())

        elif (unit == 'sky'):

            (minx, maxx) = (self.hardwareUnit.getMinX(),
                            self.hardwareUnit.getMaxX())
            (miny, maxy) = (self.hardwareUnit.getMinY(),
                            self.hardwareUnit.getMaxY())

        else:

            raise RuntimeError("Units %s are not known. Possible values: physical or sky" % (unit))

        # Adjust the horizonthal size so that we have an integer number
        # of boxes
        width = (maxx - minx)
        # The division and multiplication by 2 is a trick to make sure that
        # the width divided by horizSize/2 is an integer
        sw = numpy.rint(width / approxSize / 2.0) * 2.0
        horizSize = width / sw

        # Adjust the vertical size so that we have an integer number
        # of boxes
        height = (maxy - miny)
        sw = numpy.rint(height / approxSize / 2.0) * 2.0
        vertSize = height / sw

        # Generate boxes
        xcoords = numpy.arange(minx, maxx, horizSize / multiplicity)
        ycoords = numpy.arange(miny, maxy, vertSize / multiplicity)

        self.boxes = []

        for x in xcoords:

            for y in ycoords:
                # thisBox = Box.Box(x, y, horizSize, vertSize, 0, unit)

                self.boxes.append((x, y, horizSize, vertSize, 0, unit))


    def getBoxes(self):
        # Return the boxes generated by makeGrid
        return self.boxes


class GridGenChandra(GridGen):

    def makeGrid(self, x_pnt, y_pnt, get_psf_size, max_radius, min_size=3.0, factor=1.3):
        """
        Distribute regions radially with size and shift depending on the size of the PSF

        :param x_pnt:
        :param y_pnt:
        :param get_psf_size:
        :param max_radius:
        :param min_size:
        :param factor:
        :return:
        """

        self.boxes = []

        # Generate first box around the pointing

        first_box_size = max(2 * get_psf_size(x_pnt, y_pnt) * factor, min_size) / self.hardwareUnit.getPixelScale()

        # The box is defined by the lower left corner, not the center
        this_x = x_pnt - first_box_size
        this_y = y_pnt - first_box_size

        self.boxes.append((this_x, this_y, 2 * first_box_size, 2 * first_box_size, 0, 'sky'))

        box_size = first_box_size

        n_rounds = 0
        r = 0
        last_round = False

        while True:

            n_rounds += 1

            # Now generate boxes on the circle with radius first_box_size at an approximate distance
            # of first_box_size between themselves

            d = box_size

            r += box_size

            theta = 2 * numpy.rad2deg(numpy.arcsin(d / (2*r)))

            # change theta so that there is an integer number of regions
            n_regions = int(numpy.floor(360.0 / theta))

            #print("Loop %s, generating %s regions" % (n_rounds, n_regions))

            theta = 360.0 / n_regions

            # Generate regions in theta, phi
            for i in range(n_regions):

                this_theta = i*theta

                this_xc = r * numpy.cos(numpy.deg2rad(this_theta)) + x_pnt
                this_yc = r * numpy.sin(numpy.deg2rad(this_theta)) + y_pnt

                # The box is defined by the lower left corner, not the center
                this_x = this_xc - d
                this_y = this_yc - d

                self.boxes.append((this_x, this_y, 2*d, 2*d, 0, 'sky'))

            if last_round:

                break

            if r > max_radius:

                # Do one more round to make sure we cover up to the maximum radius (remember that empty regions
                # will be discarded anyway)

                last_round = True

            else:

                # Update box size and continue

                new_box_size = max(2 * get_psf_size(this_x, this_y) * factor, min_size) / \
                               self.hardwareUnit.getPixelScale()

                #new_box_size = max(new_box_size, 1.1 * box_size)

                box_size = new_box_size

                #print("New box size: %s" % box_size)
